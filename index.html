<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://aframe.io/releases/0.8.0/aframe.min.js"></script>
    <script src="libs/jquery-3.3.1.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.5.1/dist/aframe-look-at-component.min.js"></script>


</head>
<body>
<a-scene>
    <a-assets>
        <a-asset-item id="harvest" src="assets/models/harvest/model.dae"></a-asset-item>
        <a-asset-item id="house" src="assets/models/lighthouse/gltf.glb"></a-asset-item>
        <a-asset-item id="monk" src="assets/models/monk/model.dae"></a-asset-item>
        <a-asset-item id="cowgirl" src="assets/models/cowgirl/model.dae"></a-asset-item>
        <a-asset-item id="kids" src="assets/models/kids/model.dae"></a-asset-item>
    </a-assets>
    <a-entity camera look-controls wasd-controls></a-entity>

    <a-gltf-model position="0 -1 0" src="#house"></a-gltf-model>
    <a-collada-model look-at="[camera]" position="-18 -1 -1.3" src="#monk"></a-collada-model>
    <a-collada-model position="-23.699137807788514 -1.1669356758691327 1.4171717170095683" src="#harvest"></a-collada-model>
    <a-collada-model look-at="[camera]" position="-23.699137807788514 -1 1.4171717170095683" src="#cowgirl"></a-collada-model>
    <a-collada-model look-at="[camera]" position="-23.699 -1 -4" src="#kids"></a-collada-model>
    <a-sky src="assets/skybox.jpg"></a-sky>
</a-scene>
<script>
    const editor = "sorts\n" +
        "    #people = {sara, bob, sam, john}.\n" +
        "predicates\n" +
        "%father(X,Y) denotes that X is father of Y.\n" +
        "    father(#people, #people).\n" +
        "%mother(X,Y) denotes that X is mather of Y\n" +
        "    mother(#people, #people).\n" +
        "%parent(X,Y) denotes that X is parent of Y.\n" +
        "    parent(#people, #people).\n" +
        "%speak(X) denotes that X can speak\n" +
        "    speak(#people).\n" +
        "rules\n" +
        "    father(bob, sam).\n" +
        "    father(john, sam).\n" +
        "    parent(bob, john).\n"
    const stopwords = ["of", "the", "a", "an", "any", "is", "can", "Is"];
    const confirmedQuestion = ["is", "can"];
    const questionList = ["what", "who", "whom", "whose", "where"];
    var predicates = [];
    extractPredicates(editor);

    var synth = window.speechSynthesis;
    var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;
    var recognition = new SpeechRecognition();
    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;


    $(document).keypress(function (e) {
        if (e.which == 13) {
            ListeningMode();
        }
    });

    function extractPredicates(editorL) {
        var matches = editorL.match(/\%([^)]+)\)/gm);
        matches.forEach(function (d) {
            let predicate = d.match(/[a-z]+/gm);
            let num_variable = d.match(/\(([^\)]+)\)/gm)[0].split(',').length;
            let obj = {};
            obj.name = predicate[0];
            obj.arity = num_variable;
            predicates.push(obj);
        });
    }

    function ListeningMode() {
        recognition.start();
    }

    function SpeakingMode(tts) {
        var utterThis = new SpeechSynthesisUtterance(tts);
        synth.speak(utterThis);
        var query = processTranscript(tts);
        console.log(query)
        var data = {
            'action': "getQuery",
            'query': query,
            'editor': editor
        };

        // Expected response : answer sets
        $.post("http://wave.ttu.edu/ajax.php", data, function (response) {
            Speaking(response.replace(/<[^>]*>/gm, ""));

        });
    }

    recognition.onresult = function (event) {
        // The SpeechRecognitionEvent results property returns a SpeechRecognitionResultList object
        // The SpeechRecognitionResultList object contains SpeechRecognitionResult objects.
        // It has a getter so it can be accessed like an array
        // The [last] returns the SpeechRecognitionResult at the last position.
        // Each SpeechRecognitionResult object contains SpeechRecognitionAlternative objects that contain individual results.
        // These also have getters so they can be accessed like arrays.
        // The [0] returns the SpeechRecognitionAlternative at position 0.
        // We then return the transcript property of the SpeechRecognitionAlternative object

        var last = event.results.length - 1;
        var transcript = event.results[last][0].transcript;
        SpeakingMode(transcript);
    }

    function processTranscript(transcript) {
        let query = "";
        let temparr = transcript.toLowerCase().split(" "); //Convert to lowercase and split it
        //Remove all stop words
        temparr = temparr.filter(f => !stopwords.includes(f));


        for (let p of predicates) {
            for (let ps of temparr) {
                if (p.name == ps) {
                    //Check arity
                    let arity = new Array(p.arity);
                    //If it contain who, what, where, when
                    var q = temparr.filter(f => questionList.includes(f));
                    if (q.length > 0) {
                        //get the index and compare position
                        //Now filter the rest extract name
                        let difference = temparr.filter(x => !questionList.includes(x));
                        difference = difference.filter(x => ![ps].includes(x));
                        console.log(difference);
                        if (temparr.indexOf(q[0]) > temparr.indexOf(ps)) {
                            arity[arity.length - 1] = "X";
                            arity[0] = difference[0];
                        }
                        else {
                            arity[0] = "X";
                            arity[arity.length - 1] = difference[0];

                        }
                    }
                    else {
                        let difference = temparr.filter(x => ![ps].includes(x));
                        if (p.arity = 1) {
                            arity[0] = difference[0];
                        } else {
                            arity[0] = difference[0];
                            arity[1] = difference[1];
                        }
                    }
                    query = ps + "(" + arity.join(",") + ")";
                    break;
                }
            }
        }
        console.log(query);
        return query;
    }

    function Speaking(text) {
        var utterThis = new SpeechSynthesisUtterance(text);
        synth.speak(utterThis);
    }

</script>
</body>
</html>